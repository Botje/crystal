module Crystal.Env where

import Control.Monad
import qualified Data.Map as M
import Data.Monoid

import Crystal.AST
import Crystal.Tuple
import Crystal.Type

type Env = M.Map Ident TypedLabel

-- TODO: Factor in effects of functions passed to higher-order primitives
-- TODO: Support for floats
main_env :: Env
main_env = carLikes `M.union` M.fromListWith or [
    "1+"            --> fun [1..1] . require [(TInt,1)] TInt,
    "1-"            --> fun [1..1] . require [(TInt,1)] TInt,
    "="             --> makeNumericVarFun "="  TBool,
    "+"             --> makeNumericVarFun "+"  TInt,
    "*"             --> makeNumericVarFun "*"  TInt,
    "-"             --> makeNumericVarFun "-"  TInt,
    "/"             --> makeNumericVarFun "/"  TInt,
    "<"             --> makeNumericVarFun "<"  TBool,
    ">"             --> makeNumericVarFun ">"  TBool,
    ">="            --> makeNumericVarFun ">=" TBool,
    "<="            --> makeNumericVarFun "<=" TBool,
    "abs"           --> fun [1..1] . require [(TInt,1)] TInt,
    "acos"          --> fun [1..1] . require [(TInt,1)] TInt,
    "append"        --> fun [1..2] . require [(TList,1), (TList,2)] TList,
    "apply"         --> fun [1..2] . require [(TList,2)] TAny, -- todo function
    "arithmetic-shift" --> fun [1..2] . require [(TInt,1),(TInt,2)] TInt,
    "asin"          --> fun [1..1] . require [(TInt,1)] TInt,
    "assoc"         --> fun [1..2] . require [(TList,2)] (Tor [TPair, TBool]),
    "assq"          --> fun [1..2] . require [(TList,2)] (Tor [TPair, TBool]),
    "assv"          --> fun [1..2] . require [(TList,2)] (Tor [TPair, TBool]),
    "atan"          --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "boolean?"      --> fun [1..1] . require [] TBool,
    "call-with-input-file" --> fun [1..2] . require [(TString,1),(fun [3] TAny, 2)] TAny,
    "call-with-output-file" --> fun [1..2] . require [(TString,1),(fun [3] TAny, 2)] TAny,
    "ceiling"       --> fun [1..1] . require [(TInt,1)] TInt,
    "char?"         --> fun [1..1] . require [] TBool,
    "char->integer" --> fun [1..1] . require [(TChar, 1)] TInt,
    "char-alphabetic?" --> fun [1..1] . require [(TChar,1)] TBool,
    "char-downcase" --> fun [1..1] . require [(TChar,1)] TChar,
    "char-lower-case?" --> fun [1..1] . require [(TChar,1)] TBool,
    "char-numeric?" --> fun [1..1] . require [(TChar,1)] TBool,
    "char-upcase"   --> fun [1..1] . require [(TChar,1)] TChar,
    "char-upper-case?" --> fun [1..1] . require [(TChar,1)] TBool,
    "char-whitespace?" --> fun [1..1] . require [(TChar,1)] TBool,
    "char-ci<=?"    --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char-ci<?"     --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char-ci=?"     --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char-ci>=?"    --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char-ci>?"     --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char<=?"       --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char<?"        --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char=?"        --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char>=?"       --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char>?"        --> fun [1..2] . require [(TChar,1),(TChar,2)] TBool,
    "char?"         --> fun [1..1] . require [] TBool,
    "close-input-port" --> fun [1..1] . require [(TPort, 1)] TVoid,
    "close-output-port" --> fun [1..1] . require [(TPort, 1)] TVoid,
    "complex?"      --> fun [1..1] . require [] TBool,
    "cons"          --> fun [1..2] . require [(TList,2)] TList,
    "cons"          --> fun [1..2] . require [] TPair,
    "cos"           --> fun [1..1] . require [(TInt,1)] TInt,
    "current-input-port" --> fun [1..1] . require [] TPort,
    "current-output-port" --> fun [1..1] . require [] TPort,
    "display"       --> fun [1..1] . require [] TVoid,
    "eof-object?"   --> fun [1..1] . require [] TBool,
    "eq?"           --> fun [1..2] . require [] TBool,
    "equal?"        --> fun [1..2] . require [] TBool,
    "eqv?"          --> fun [1..2] . require [] TBool,
    "error"         --> fun [1..1] . require [(TString,1)] TAny,
    "even?"         --> fun [1..1] . require [] TBool,
    "exact?"        --> fun [1..1] . require [] TBool,
    "exact->inexact"--> fun [1..1] . require [(TInt,1)] TInt,
    "exp"           --> fun [1..1] . require [(TInt,1)] TInt,
    "expt"          --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "floor"         --> fun [1..1] . require [(TInt,1)] TInt,
    "for-each"      --> fun [1..2] . require [(fun [3] TAny,1), (TList,2)] TVoid,
    "format"        --> makeVarFun "format" (\args -> require [] TString),
    "fp="           --> makeNumericVarFun "="  TBool,
    "fp+"           --> makeNumericVarFun "+"  TInt,
    "fp*"           --> makeNumericVarFun "*"  TInt,
    "fp-"           --> makeNumericVarFun "-"  TInt,
    "fp/"           --> makeNumericVarFun "/"  TInt,
    "fp<"           --> makeNumericVarFun "<"  TBool,
    "fp>"           --> makeNumericVarFun ">"  TBool,
    "fp>="          --> makeNumericVarFun ">=" TBool,
    "fp<="          --> makeNumericVarFun "<=" TBool,
    "fx="           --> makeNumericVarFun "="  TBool,
    "fx+"           --> makeNumericVarFun "+"  TInt,
    "fx*"           --> makeNumericVarFun "*"  TInt,
    "fx-"           --> makeNumericVarFun "-"  TInt,
    "fx/"           --> makeNumericVarFun "/"  TInt,
    "fx<"           --> makeNumericVarFun "<"  TBool,
    "fx>"           --> makeNumericVarFun ">"  TBool,
    "fx>="          --> makeNumericVarFun ">=" TBool,
    "fx<="          --> makeNumericVarFun "<=" TBool,
    "fxmin"         --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "fxmod"         --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "gcd"           --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "gensym"        --> fun []     . require [] TSymbol,
    "inexact?"      --> fun [1..1] . require [] TBool,
    "inexact->exact"--> fun [1..1] . require [(TInt,1)] TInt,
    "integer?"      --> fun [1..1] . require [] TBool,
    "integer->char" --> fun [1..1] . require [(TInt,1)] TChar,
    "input-port?"   --> fun [1..1] . require [] TBool,
    "lcm"           --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "length"        --> fun [1..1] . require [(TList,1)] TInt,
    "list"          --> makeVarFun "list" (\args -> require [] TList),
    "list?"         --> fun [1..1] . require [] TBool,
    "list->vector"  --> fun [1..1] . require [(TList,1)] TVec,
    "list-ref"      --> fun [1..2] . require [(TList,1), (TInt,2)] TAny,
    "log"           --> fun [1..1] . require [(TInt,1)] TInt,
    "make-string"   --> fun [1..1] . require [(TInt,1)] TString,
    "make-vector"   --> fun [1..1] . require [(TInt,1)] TVec,
    "make-vector"   --> fun [1..2] . require [(TInt,1)] TVec,
    "map"           --> fun [1..2] . require [(fun [3] TAny,1), (TList,2)] TList,
    "max"           --> fun [1..2] . require [(TInt,1), (TInt,2)] TBool,
    "member"        --> fun [1..2] . require [(TList, 2)] (Tor [TPair, TBool]),
    "memq"          --> fun [1..2] . require [(TList, 2)] (Tor [TPair, TBool]),
    "memv"          --> fun [1..2] . require [(TList, 2)] (Tor [TPair, TBool]),
    "min"           --> fun [1..2] . require [(TInt,1), (TInt,2)] TBool,
    "modulo"        --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "negative?"     --> fun [1..1] . require [] TBool,
    "newline"       --> fun []     . require [] TVoid,
    "not"           --> fun [1..1] . require [] TBool,
    "null?"         --> fun [1..1] . require [] TBool,
    "number?"       --> fun [1..1] . require [] TBool,
    "number->string"--> fun [1..1] . require [(TInt,1)] TString,
    "odd?"          --> fun [1..1] . require [] TBool,
    "open-input-file" --> fun [1..1] . require [(TString,1)] TPort,
    "open-output-file" --> fun [1..1] . require [(TString,1)] TPort,
    "output-port?"  --> fun [1..1] . require [] TBool,
    "pair?"         --> fun [1..1] . require [] TBool,
    "peek-char"     --> fun []     . require [] TChar,
    "peek-char"     --> fun [1..1] . require [(TPort,1)] TChar,
    "port?"         --> fun [1..1] . require [] TBool,
    "positive?"     --> fun [1..1] . require [] TBool,
    "procedure?"    --> fun [1..1] . require [] TBool,
    "print"         --> makeVarFun "print" (\args -> require [] TVoid),
    "printf"        --> makeVarFun "printf" (\args -> require [] TVoid),
    "quotient"      --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "rational?"     --> fun [1..1] . require [] TBool,
    "read"          --> fun []     . require [] TAny,
    "read-char"     --> fun [1..1] . require [(TPort, 1)] TChar,
    "read-line"     --> fun [1..1] . require [(TPort, 1)] TString,
    "real?"         --> fun [1..1] . require [] TBool,
    "remainder"     --> fun [1..2] . require [(TInt,1), (TInt,2)] TInt,
    "reverse"       --> fun [1..1] . require [(TList,1)] TList,
    "round"         --> fun [1..1] . require [(TInt,1)] TInt,
    "set-car!"      --> fun [1..2] . require [(TPair, 1)] TVoid,
    "set-cdr!"      --> fun [1..2] . require [(TPair, 1)] TVoid,
    "sin"           --> fun [1..1] . require [(TInt,1)] TInt,
    "sqrt"          --> fun [1..1] . require [(TInt,1)] TInt,
    "string"        --> makeVarFun "string" (\args -> requireVF [(TChar,a) | a <- args] TString),
    "string-append" --> fun [1..2] . require [(TString,1), (TString,2)] TString,
    "string?"       --> fun [1..1] . require [] TBool,
    "string<=?"     --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string<?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string=?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string>=?"     --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string>?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-ci<=?"     --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-ci<?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-ci=?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-ci>=?"     --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-ci>?"      --> fun [1..2] . require [(TString,1),(TString,2)] TBool,
    "string-chop"   --> fun [1..2] . require [(TString,1), (TInt, 2)] TPair,
    "string->list"     --> fun [1..1] . require [(TString,1)] TList,
    "string->number"   --> fun [1..1] . require [(TString,1)] TInt,
    "string->symbol"   --> fun [1..1] . require [(TString,1)] TSymbol,
    "string-downcase"  --> fun [1..1] . require [(TString,1)] TString,
    "string-downcase!" --> fun [1..1] . require [(TString,1)] TVoid,
    "string-length" --> fun [1..1] . require [(TString,1)] TInt,
    "string-ref"    --> fun [1..2] . require [(TString,1), (TInt, 2)] TChar,
    "string-reverse" --> fun [1..1] . require [(TString,1)] TString,
    "string-set!"   --> fun [1..3] . require [(TString,1), (TInt, 2), (TChar, 3)] TVoid,
    "string-upcase" --> fun [1..1] . require [(TString,1)] TString,
    "string-upcase!"--> fun [1..1] . require [(TString,1)] TVoid,
    "substring"     --> fun [1..3] . require [(TString,1), (TInt, 2), (TInt, 3)] TString,
    "symbol?"       --> fun [1..1] . require [] TBool,
    "symbol->string"--> fun [1..1] . require [(TSymbol,1)] TString,
    "tan"           --> fun [1..1] . require [(TInt,1)] TInt,
    "time"          --> fun [1..1] . require [] TAny,
    "truncate"      --> fun [1..1] . require [(TInt,1)] TInt,
    "vector->list"  --> fun [1..1] . require [(TVec,1)] TList,
    "vector-length" --> fun [1..1] . require [(TVec,1)] TInt,
    "vector-ref"    --> fun [1..2] . require [(TVec,1), (TInt,2)] TAny,
    "vector-resize" --> fun [1..3] . require [(TVec,1), (TInt,2)] TVec,
    "vector-set!"   --> fun [1..3] . require [(TVec,1), (TInt,2)] TVoid,
    "vector"        --> makeVarFun "vector" (\args -> require [] TVec),
    "vector?"       --> fun [1..1] . require [] TBool,
    "void?"         --> fun [1..1] . require [] TBool,
    "with-input-from-file" --> fun [1..2] . require [(TString,1)] TVoid,
    "with-output-to-file"  --> fun [1..2] . require [(TString,1)] TVoid,
    "write"         --> fun [1..1] . require [(TString,1)] TVoid,
    "write-char"    --> fun [1..1] . require [(TChar,1)] TVoid,
    "write-line"    --> fun [1..1] . require [(TString,1)] TVoid,
    "zero?"         --> fun [1..1] . require [] TBool
  ] where (-->) nam fun = (nam, LPrim nam :*: fun (LPrim nam) :*: emptyEffect)
          infix 5 -->
          require tests return blame       = foldr f return tests
            where f (prim, cause) return = TIf (blame, LVar cause) prim (TVar cause) return
          requireVF tests return blame     = foldr f return tests
            where f (prim, cause :*: typ) return = TIf (blame, cause) prim typ return
          makeVarFun name vf blame         = TVarFun (VarFun name blame vf)
          makeNumericVarFun name ret blame = TVarFun (VarFun name blame (\args blame -> requireVF [ (TInt, a) | a <- args ] ret blame))
          fun args typ = TFun args emptyEffect typ
          (LPrim nam :*: fun1 :*: ef1) `or` (LPrim _ :*: fun2 :*: ef2) = LPrim nam :*: Tor [fun1, fun2] :*: ef1 `mappend` ef2

carLikes = M.fromList [ (id, LPrim id :*: carLikeType id :*: emptyEffect) | n <- [1..4], mid <- replicateM n "ad", let id = "c" ++ mid ++ "r" ]
  where carLikeType id = TFun [1] emptyEffect $ TIf (LPrim id, LVar 1) TPair (TVar 1) TAny
extend :: Ident -> TypedLabel -> Env -> Env
extend = M.insert
